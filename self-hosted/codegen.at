// Athōn Code Generator - Written in Athōn
// Generates C code from AST

// AST Node Types (must match parser)
fn NODE_NUMBER() -> int { return 1; }
fn NODE_IDENTIFIER() -> int { return 2; }
fn NODE_BINARY_OP() -> int { return 3; }
fn NODE_UNARY_OP() -> int { return 4; }
fn NODE_CALL() -> int { return 5; }
fn NODE_LET() -> int { return 10; }
fn NODE_ASSIGN() -> int { return 11; }
fn NODE_IF() -> int { return 12; }
fn NODE_WHILE() -> int { return 13; }
fn NODE_RETURN() -> int { return 14; }
fn NODE_FUNCTION() -> int { return 20; }
fn NODE_PROGRAM() -> int { return 30; }

// Binary operators
fn OP_ADD() -> int { return 1; }
fn OP_SUB() -> int { return 2; }
fn OP_MUL() -> int { return 3; }
fn OP_DIV() -> int { return 4; }
fn OP_EQ() -> int { return 5; }
fn OP_NEQ() -> int { return 6; }
fn OP_LT() -> int { return 7; }
fn OP_GT() -> int { return 8; }

// AST Node (simplified)
struct ASTNode {
    node_type: int,
    value: int,
    op: int,
    line: int,
}

// Code generation state
struct CodeGen {
    indent_level: int,
    temp_count: int,
}

// Emit indentation
fn emit_indent(level: int) {
    let i = 0;
    while i < level {
        print("    ", "");
        i = i + 1;
    }
}

// Emit C operator
fn emit_operator(op: int) {
    if op == OP_ADD() { print("+", ""); }
    if op == OP_SUB() { print("-", ""); }
    if op == OP_MUL() { print("*", ""); }
    if op == OP_DIV() { print("/", ""); }
    if op == OP_EQ() { print("==", ""); }
    if op == OP_NEQ() { print("!=", ""); }
    if op == OP_LT() { print("<", ""); }
    if op == OP_GT() { print(">", ""); }
}

// Generate expression
fn gen_expression(gen: CodeGen, node: ASTNode) {
    // Number literal
    if node.node_type == NODE_NUMBER() {
        print("{}", node.value);
        return;
    }
    
    // Identifier
    if node.node_type == NODE_IDENTIFIER() {
        print("x", "");  // Simplified
        return;
    }
    
    // Binary operation
    if node.node_type == NODE_BINARY_OP() {
        print("(", "");
        print("left", "");  // Would recursively generate left
        print(" ", "");
        emit_operator(node.op);
        print(" ", "");
        print("right", "");  // Would recursively generate right
        print(")", "");
        return;
    }
}

// Generate let statement
fn gen_let_statement(gen: CodeGen, node: ASTNode) {
    emit_indent(gen.indent_level);
    print("int x = 0;");
}

// Generate assignment
fn gen_assign_statement(gen: CodeGen, node: ASTNode) {
    emit_indent(gen.indent_level);
    print("x = ", "");
    gen_expression(gen, node);
    print(";");
}

// Generate if statement
fn gen_if_statement(gen: CodeGen, node: ASTNode) {
    emit_indent(gen.indent_level);
    print("if (condition) {");
    emit_indent(gen.indent_level);
    print("}");
}

// Generate while statement
fn gen_while_statement(gen: CodeGen, node: ASTNode) {
    emit_indent(gen.indent_level);
    print("while (condition) {");
    emit_indent(gen.indent_level);
    print("}");
}

// Generate return statement
fn gen_return_statement(gen: CodeGen, node: ASTNode) {
    emit_indent(gen.indent_level);
    print("return ", "");
    gen_expression(gen, node);
    print(";");
}

// Generate statement
fn gen_statement(gen: CodeGen, node: ASTNode) {
    if node.node_type == NODE_LET() {
        gen_let_statement(gen, node);
        return;
    }
    
    if node.node_type == NODE_ASSIGN() {
        gen_assign_statement(gen, node);
        return;
    }
    
    if node.node_type == NODE_IF() {
        gen_if_statement(gen, node);
        return;
    }
    
    if node.node_type == NODE_WHILE() {
        gen_while_statement(gen, node);
        return;
    }
    
    if node.node_type == NODE_RETURN() {
        gen_return_statement(gen, node);
        return;
    }
}

// Generate function
fn gen_function(gen: CodeGen, name: int) {
    print("int add(int a, int b) {");
    
    let new_gen = CodeGen {
        indent_level: gen.indent_level + 1,
        temp_count: 0,
    };
    
    // Generate body
    emit_indent(new_gen.indent_level);
    print("return a + b;");
    
    print("}");
}

// Generate C header
fn gen_header() {
    print("#include <stdio.h>");
    print("#include <stdlib.h>");
    print("");
}

// Generate main function
fn gen_main(gen: CodeGen) {
    print("int main() {");
    
    let new_gen = CodeGen {
        indent_level: 1,
        temp_count: 0,
    };
    
    emit_indent(new_gen.indent_level);
    print("int x = 5;");
    
    emit_indent(new_gen.indent_level);
    print("int y = 3;");
    
    emit_indent(new_gen.indent_level);
    print("int result = x + y;");
    
    emit_indent(new_gen.indent_level);
    print("printf(\"Result: %d\\n\", result);");
    
    emit_indent(new_gen.indent_level);
    print("return 0;");
    
    print("}");
}

// Generate complete program
fn gen_program(gen: CodeGen) {
    gen_header();
    print("");
    gen_function(gen, 0);
    print("");
    gen_main(gen);
}

// Demo: Generate sample C code
fn demo_simple_expression() {
    print("=== Demo 1: Simple Expression ===");
    print("");
    
    let gen = CodeGen {
        indent_level: 0,
        temp_count: 0,
    };
    
    let node = ASTNode {
        node_type: NODE_NUMBER(),
        value: 42,
        op: 0,
        line: 1,
    };
    
    print("Generating: 42");
    print("C code: ", "");
    gen_expression(gen, node);
    print("");
    print("");
}

fn demo_binary_expression() {
    print("=== Demo 2: Binary Expression ===");
    print("");
    
    let gen = CodeGen {
        indent_level: 0,
        temp_count: 0,
    };
    
    let node = ASTNode {
        node_type: NODE_BINARY_OP(),
        value: 0,
        op: OP_ADD(),
        line: 1,
    };
    
    print("Generating: left + right");
    print("C code: ", "");
    gen_expression(gen, node);
    print("");
    print("");
}

fn demo_statements() {
    print("=== Demo 3: Statements ===");
    print("");
    
    let gen = CodeGen {
        indent_level: 1,
        temp_count: 0,
    };
    
    print("Let statement:");
    let let_node = ASTNode {
        node_type: NODE_LET(),
        value: 0,
        op: 0,
        line: 1,
    };
    gen_let_statement(gen, let_node);
    print("");
    
    print("Return statement:");
    let ret_node = ASTNode {
        node_type: NODE_RETURN(),
        value: 42,
        op: 0,
        line: 1,
    };
    gen_return_statement(gen, ret_node);
    print("");
    print("");
}

fn demo_complete_program() {
    print("=== Demo 4: Complete C Program ===");
    print("");
    
    let gen = CodeGen {
        indent_level: 0,
        temp_count: 0,
    };
    
    gen_program(gen);
    print("");
}

fn main() {
    print("=== Athōn Self-Hosted Code Generator ===");
    print("");
    print("Generates C code from Athōn AST");
    print("");
    
    // Run demos
    demo_simple_expression();
    demo_binary_expression();
    demo_statements();
    demo_complete_program();
    
    print("=== Code Generator Demo Complete ===");
    print("");
    print("The code generator demonstrates:");
    print("  1. Expression code generation");
    print("  2. Statement code generation");
    print("  3. Function code generation");
    print("  4. Complete program generation");
    print("  5. C code emission");
}
