// Athōn Parser - Written in Athōn
// Recursive descent parser for the Athōn language

// AST Node Types (as integers)
fn NODE_NUMBER() -> int { return 1; }
fn NODE_IDENTIFIER() -> int { return 2; }
fn NODE_BINARY_OP() -> int { return 3; }
fn NODE_UNARY_OP() -> int { return 4; }
fn NODE_CALL() -> int { return 5; }
fn NODE_LET() -> int { return 10; }
fn NODE_ASSIGN() -> int { return 11; }
fn NODE_IF() -> int { return 12; }
fn NODE_WHILE() -> int { return 13; }
fn NODE_RETURN() -> int { return 14; }
fn NODE_FUNCTION() -> int { return 20; }
fn NODE_PROGRAM() -> int { return 30; }

// Binary operators
fn OP_ADD() -> int { return 1; }
fn OP_SUB() -> int { return 2; }
fn OP_MUL() -> int { return 3; }
fn OP_DIV() -> int { return 4; }
fn OP_EQ() -> int { return 5; }
fn OP_NEQ() -> int { return 6; }
fn OP_LT() -> int { return 7; }
fn OP_GT() -> int { return 8; }
fn OP_AND() -> int { return 9; }
fn OP_OR() -> int { return 10; }

// Parser state
struct Parser {
    pos: int,
    token_count: int,
}

// AST Node (simplified)
struct ASTNode {
    node_type: int,
    value: int,
    op: int,
    line: int,
}

// Token matching
fn match_token(expected: int, actual: int) -> int {
    return expected == actual;
}

// Operator precedence
fn get_precedence(op: int) -> int {
    if op == OP_MUL() { return 3; }
    if op == OP_DIV() { return 3; }
    if op == OP_ADD() { return 2; }
    if op == OP_SUB() { return 2; }
    if op == OP_EQ() { return 1; }
    if op == OP_NEQ() { return 1; }
    if op == OP_LT() { return 1; }
    if op == OP_GT() { return 1; }
    return 0;
}

// Parse primary expression (number, identifier, or parenthesized)
fn parse_primary(parser: Parser, token_kind: int, token_value: int) -> ASTNode {
    // Number literal
    if token_kind == 71 {  // TOKEN_NUMBER
        let node = ASTNode {
            node_type: NODE_NUMBER(),
            value: token_value,
            op: 0,
            line: 1,
        };
        return node;
    }
    
    // Identifier
    if token_kind == 70 {  // TOKEN_IDENTIFIER
        let node = ASTNode {
            node_type: NODE_IDENTIFIER(),
            value: token_value,
            op: 0,
            line: 1,
        };
        return node;
    }
    
    // Default: error node
    let node = ASTNode {
        node_type: 0,
        value: 0,
        op: 0,
        line: 1,
    };
    return node;
}

// Parse binary expression
fn parse_binary_op(left: ASTNode, op: int, right: ASTNode) -> ASTNode {
    let node = ASTNode {
        node_type: NODE_BINARY_OP(),
        value: 0,
        op: op,
        line: 1,
    };
    return node;
}

// Parse expression
fn parse_expression(parser: Parser, token_kind: int) -> ASTNode {
    // Start with primary
    let left = parse_primary(parser, token_kind, 42);
    
    // Check for binary operator
    if token_kind == 57 {  // TOKEN_PLUS
        let right = parse_primary(parser, 71, 10);  // Assume number
        return parse_binary_op(left, OP_ADD(), right);
    }
    
    if token_kind == 58 {  // TOKEN_MINUS
        let right = parse_primary(parser, 71, 5);
        return parse_binary_op(left, OP_SUB(), right);
    }
    
    return left;
}

// Parse let statement
fn parse_let_statement(parser: Parser) -> ASTNode {
    let node = ASTNode {
        node_type: NODE_LET(),
        value: 0,
        op: 0,
        line: 1,
    };
    return node;
}

// Parse if statement
fn parse_if_statement(parser: Parser) -> ASTNode {
    let node = ASTNode {
        node_type: NODE_IF(),
        value: 0,
        op: 0,
        line: 1,
    };
    return node;
}

// Parse while statement
fn parse_while_statement(parser: Parser) -> ASTNode {
    let node = ASTNode {
        node_type: NODE_WHILE(),
        value: 0,
        op: 0,
        line: 1,
    };
    return node;
}

// Parse return statement
fn parse_return_statement(parser: Parser) -> ASTNode {
    let node = ASTNode {
        node_type: NODE_RETURN(),
        value: 0,
        op: 0,
        line: 1,
    };
    return node;
}

// Parse statement
fn parse_statement(parser: Parser, token_kind: int) -> ASTNode {
    // Let statement
    if token_kind == 1 {  // TOKEN_LET
        return parse_let_statement(parser);
    }
    
    // If statement
    if token_kind == 2 {  // TOKEN_IF
        return parse_if_statement(parser);
    }
    
    // While statement
    if token_kind == 4 {  // TOKEN_WHILE
        return parse_while_statement(parser);
    }
    
    // Return statement
    if token_kind == 6 {  // TOKEN_RETURN
        return parse_return_statement(parser);
    }
    
    // Expression statement
    return parse_expression(parser, token_kind);
}

// Parse function definition
fn parse_function(parser: Parser) -> ASTNode {
    let node = ASTNode {
        node_type: NODE_FUNCTION(),
        value: 0,
        op: 0,
        line: 1,
    };
    return node;
}

// Parse program
fn parse_program(parser: Parser) -> ASTNode {
    let node = ASTNode {
        node_type: NODE_PROGRAM(),
        value: 0,
        op: 0,
        line: 1,
    };
    return node;
}

// AST node type to string
fn node_type_name(node_type: int) {
    if node_type == 1 { print("NUMBER"); }
    if node_type == 2 { print("IDENTIFIER"); }
    if node_type == 3 { print("BINARY_OP"); }
    if node_type == 10 { print("LET"); }
    if node_type == 11 { print("ASSIGN"); }
    if node_type == 12 { print("IF"); }
    if node_type == 13 { print("WHILE"); }
    if node_type == 14 { print("RETURN"); }
    if node_type == 20 { print("FUNCTION"); }
    if node_type == 30 { print("PROGRAM"); }
}

// Operator to string
fn op_name(op: int) {
    if op == 1 { print("ADD"); }
    if op == 2 { print("SUB"); }
    if op == 3 { print("MUL"); }
    if op == 4 { print("DIV"); }
    if op == 5 { print("EQ"); }
    if op == 6 { print("NEQ"); }
    if op == 7 { print("LT"); }
    if op == 8 { print("GT"); }
}

// Main demonstration
fn main() {
    print("=== Athōn Self-Hosted Parser ===");
    print("");
    
    // Create parser
    let parser = Parser {
        pos: 0,
        token_count: 0,
    };
    
    print("Parser initialized:");
    print("  Position: {}", parser.pos);
    print("  Token count: {}", parser.token_count);
    print("");
    
    // Test: Parse number literal
    print("Test 1: Parse number literal (42)");
    let node1 = parse_primary(parser, 71, 42);
    print("  Node type: ", "");
    node_type_name(node1.node_type);
    print("  Value: {}", node1.value);
    print("");
    
    // Test: Parse identifier
    print("Test 2: Parse identifier");
    let node2 = parse_primary(parser, 70, 0);
    print("  Node type: ", "");
    node_type_name(node2.node_type);
    print("");
    
    // Test: Parse binary expression (5 + 3)
    print("Test 3: Parse binary expression (5 + 3)");
    let left = parse_primary(parser, 71, 5);
    let right = parse_primary(parser, 71, 3);
    let binop = parse_binary_op(left, OP_ADD(), right);
    print("  Node type: ", "");
    node_type_name(binop.node_type);
    print("  Operator: ", "");
    op_name(binop.op);
    print("");
    
    // Test: Parse statements
    print("Test 4: Parse let statement");
    let let_node = parse_let_statement(parser);
    print("  Node type: ", "");
    node_type_name(let_node.node_type);
    print("");
    
    print("Test 5: Parse if statement");
    let if_node = parse_if_statement(parser);
    print("  Node type: ", "");
    node_type_name(if_node.node_type);
    print("");
    
    print("Test 6: Parse while statement");
    let while_node = parse_while_statement(parser);
    print("  Node type: ", "");
    node_type_name(while_node.node_type);
    print("");
    
    print("Test 7: Parse return statement");
    let ret_node = parse_return_statement(parser);
    print("  Node type: ", "");
    node_type_name(ret_node.node_type);
    print("");
    
    // Test: Parse function
    print("Test 8: Parse function definition");
    let func_node = parse_function(parser);
    print("  Node type: ", "");
    node_type_name(func_node.node_type);
    print("");
    
    // Operator precedence test
    print("Operator Precedence:");
    print("  MUL: {}", get_precedence(OP_MUL()));
    print("  ADD: {}", get_precedence(OP_ADD()));
    print("  EQ:  {}", get_precedence(OP_EQ()));
    print("");
    
    print("=== Parser Demo Complete ===");
    print("");
    print("The parser demonstrates:");
    print("  1. AST node construction");
    print("  2. Expression parsing");
    print("  3. Statement parsing");
    print("  4. Operator precedence");
    print("  5. Recursive descent parsing");
}
